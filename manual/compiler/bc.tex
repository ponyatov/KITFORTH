\clearpage
\secrel{Байт-код}\label{bc}\secdown

\begin{framed}\noindent
\termdef{Байт-код}{байт-код}\ --- (чаще вcего) платформенно-независимое
\emph{представление программ, близкое по формату к машинному коду}, но
выполняется с помощью интерпретации другой программой, обычно написанной на
высокоуровневом языке программирования.
\end{framed}

Для образцовой реализации интерпретатора была выбрана модель интерпретации
байт-кода. Его выполнение (низкоуровневая интерпретация) значительно замедляет
время работы программ, но в нашем случае это совершенно не важно\ --- задержка
до пары секунд некритична для управления работой электроплиты. Вы ведь не
собираетесь майнить на тостере?

\clearpage
\emph{Главное достоинство применения байт-кода для встроенных приложений}\ ---
не только независимость от платформы\note{в определенной мере\ --- текстовый
интерфейс с окнами а-ля TurboVision для текстового терминала может одинаково
работать на любом железе, а набор кнопок и количество ТЭНов отличается для
каждого кухонного прибора}, а прежде всего \emph{полностью контролируемое вами
выполенение кода}, и произвольный выбор системы команд и архитектуры
\term{виртуальной машины}\note{не путайте с байт-кодом Java, который
стандартизирован в рамках платформы JVM, здесь вы сами решаете сколько бит
отдать под код команды, использовать ли \F-стек или регистровую RISC-машину, и
какие команды добавить для отрисовки элементов GUI}.

Вот как раз контролируемое выполнение важно для бытовой техники: текущая
реализация \kf\ этого не делает, но в будущих версиях будут добавляться проверки
на возникновение критических ситуаций, вызванных подачей команд выводящих
устройство в аварийный режим\note{превышение максимальной рабочей температуры,
попытки включения СВЧ с открытой дверцей, и т.п.}.

Для исключения подобных ситуаций некоторые команды должны быть доступны
пользователям только в виде высокоуровневых команд, а критические управляющие
последовательности реализованы внутри прошивки. В конечном итоге, благодаря
произвольному выбору команд виртуальной машины, \textbf{вы} сами решаете, в
какой степени давать пользователям доступ к реальному ``железу'', а что
виртуализировать и предоставить безопасное API.

Как пример, можно взять контроллер электровелосипеда\note{не автомобиля,
система электропитания которого вполне потянет несколько десятков автономных
контроллеров, выделенных отдельно для каждой задачи\ --- для электровелосипеда
экономичность в смысле энергопотребления и стоимости оборудования более важна}.
В нем вам нужно реализовать управление приводом, электропитанием, тормозами,
сигнальным освещением, и мультимедиа-систему с навигацией. Применив
интерпретатор байт-кода для загрузки произвольных пользовательских программ, вы
сможете полностью ограничить доступ к двигателю, для батареи отдавать только
уровень заряда и токи/потребление, дать возможность автоматически тормозить с
ограниченной интенсивностью, но исключить разблокировку тормозов, а для GPS,
мультимедиа и GPIO дать прямой доступ к аппаратным портам.

Аналогично, для электроплиты вы можете произвольно включать и выключать
освещение и нагреватели, но физические кнопки и регуляторы имеют приоритет, и
выполнение программы приостанавливается как только хозяйка вынужденно
вмешивается в ее работу.

\clearpage
\subsecly{Интерпретор байт-кода как средство обучения}

Если вам интересует системное программирование или разработка языков
программирования и компиляторов, собственный интерпретатор байт-кода является
великолемным средством обучения.

Вы получаете полностью контролируемую виртуальную машину и симулятор, работающую
как обычное проложение в том окружении, которое вам удобно\ --- Linux консоль,
Window/GUI, или может быть Android приложение с интерактивным отладчиком, с
которым можно поиграться, пока вы едете на работу.

Вам не нужно будет вчитываться в огромные мануалы на процессор, и учитывать все
тонкости платформы, но при этом вы получаете полный комплект проблем, с которыми
сталкиваются системые программисты, когда начинают работать на новом железе
(типа разработки ПО для заказного процессора на FPGA). Вам также придется
поработать с машинным кодом (виртуальной машины), написать свой ассемблер, ОС,
компилятор и стандартную библиотеку, GUI, сетевой стек и т.д.

Но при этом вы будете работать в привычном окружении, с открытым браузером для
поиска документации, редакторами, и одновременно иметь возможность
самостоятельно дописать в интерпретор байткода самые навороченные способы
отладки и трассировки, пользуясь любым удобным для вас языком программирования,
хоть JavaScript.

\secup
